{"version":3,"sources":["../../../projects/angular-jwt/src/lib/jwt-utils.ts","../../../projects/angular-jwt/src/lib/jwtoptions.token.ts","../../../projects/angular-jwt/src/lib/jwthelper.service.ts","../../../projects/angular-jwt/src/lib/jwt.interceptor.ts","../../../projects/angular-jwt/src/lib/angular-jwt.module.ts"],"names":["getTokenExpirationDate","decoded","hasOwnProperty","date","Date","setUTCSeconds","exp","decodeToken","tokenValue","parts","split","length","Error","str","output","replace","decodeURIComponent","Array","prototype","map","call","String","bc","bs","buffer","idx","charAt","fromCharCode","indexOf","b64decode","c","charCodeAt","toString","slice","join","b64DecodeUnicode","urlBase64Decode","JSON","parse","isTokenExpired","token","offsetSeconds","valueOf","JWT_OPTIONS","InjectionToken","nullGetter","JwtHelperService","config","this","tokenGetter","Promise","then","_this","getAuthScheme","authScheme","request","Injectable","Inject","args","JwtInterceptor","jwtHelper","document","standardPorts","headerName","allowedDomains","disallowedRoutes","throwNoTokenError","skipWhenExpired","isAllowedDomain","requestUrl","URL","url","location","origin","host","hostName","hostname","port","includes","findIndex","domain","RegExp","test","isDisallowedRoute","requestedUrl","route","parsedRoute","pathname","handleInterception","next","tokenIsExpired","clone","setHeaders","_a","handle","intercept","from","pipe","mergeMap","asyncToken","Document","decorators","type","DOCUMENT","JwtModule","parentModule","forRoot","options","ngModule","providers","provide","HTTP_INTERCEPTORS","useClass","multi","jwtOptionsProvider","useValue","NgModule","Optional","SkipSelf"],"mappings":"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","sourcesContent":["export function getTokenExpirationDate(decoded: any): Date | null {\n  if (!decoded || !decoded.hasOwnProperty('exp')) {\n    return null;\n  }\n\n  const date = new Date(0);\n  date.setUTCSeconds(decoded.exp);\n\n  return date;\n}\n\nexport function decodeToken(tokenValue: string) {\n  const parts = tokenValue.split('.');\n\n  if (parts.length !== 3) {\n    throw new Error(\n      'The inspected token doesn\\'t appear to be a JWT. Check to make sure it has three parts and see https://jwt.io for more.'\n    );\n  }\n\n  const decoded = urlBase64Decode(parts[1]);\n  if (!decoded) {\n    throw new Error('Cannot decode the token.');\n  }\n\n  return JSON.parse(decoded);\n}\n\nexport function isTokenExpired(token: string, offsetSeconds: number = 0): boolean {\n  const date = getTokenExpirationDate(token);\n\n  if (date === null) {\n    return false;\n  }\n\n  return !(date.valueOf() > new Date().valueOf() + offsetSeconds * 1000);\n}\n\n\n// tslint:disable:no-bitwise\n\n// credits for decoder goes to https://github.com/atk\nfunction b64decode(str: string): string {\n  const chars =\n    'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n  let output = '';\n\n  str = String(str).replace(/=+$/, '');\n\n  if (str.length % 4 === 1) {\n    throw new Error(\n      '\\'atob\\' failed: The string to be decoded is not correctly encoded.'\n    );\n  }\n\n  for (\n    // initialize result and counters\n    let bc = 0, bs: any, buffer: any, idx = 0;\n    // get next character\n    (buffer = str.charAt(idx++));\n    // character found in table? initialize bit storage and add its ascii value;\n    ~buffer &&\n    ((bs = bc % 4 ? bs * 64 + buffer : buffer),\n      // and if not first of each 4 characters,\n      // convert the first 8 bits to one ascii character\n    bc++ % 4)\n      ? (output += String.fromCharCode(255 & (bs >> ((-2 * bc) & 6))))\n      : 0\n  ) {\n    // try to find character in table (0-63, not found => -1)\n    buffer = chars.indexOf(buffer);\n  }\n  return output;\n}\n\nfunction b64DecodeUnicode(str: any) {\n  return decodeURIComponent(\n    Array.prototype.map\n         .call(b64decode(str), (c: any) => {\n           return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);\n         })\n         .join('')\n  );\n}\n\nfunction urlBase64Decode(str: string): string {\n  let output = str.replace(/-/g, '+').replace(/_/g, '/');\n  switch (output.length % 4) {\n    case 0: {\n      break;\n    }\n    case 2: {\n      output += '==';\n      break;\n    }\n    case 3: {\n      output += '=';\n      break;\n    }\n    default: {\n      throw new Error('Illegal base64url string!');\n    }\n  }\n  return b64DecodeUnicode(output);\n}\n","import { InjectionToken } from '@angular/core';\n\nexport const JWT_OPTIONS = new InjectionToken('JWT_OPTIONS');\n","import { HttpRequest } from '@angular/common/http';\nimport { Inject, Injectable } from '@angular/core';\nimport { JwtConfig } from 'angular-jwt/lib/angular-jwt.module';\nimport { TokenGetter } from 'angular-jwt/lib/jwt.interceptor';\nimport { decodeToken, getTokenExpirationDate, isTokenExpired } from './jwt-utils';\nimport { JWT_OPTIONS } from './jwtoptions.token';\n\nfunction nullGetter() {\n  return null;\n}\n\n@Injectable()\nexport class JwtHelperService {\n  tokenGetter: TokenGetter;\n\n  constructor(@Inject(JWT_OPTIONS) config: JwtConfig = {}) {\n    this.tokenGetter = config.tokenGetter || nullGetter;\n  }\n\n  public decodeToken(token: string): any;\n  public decodeToken(token: Promise<string>): Promise<any>;\n  public decodeToken(\n    token: string | Promise<string> = this.tokenGetter()\n  ): any | Promise<any> {\n    if (token instanceof Promise) {\n      return token.then((tokenValue: string) => decodeToken(tokenValue));\n    }\n\n    if (!token || token === '') {\n      return null;\n    }\n\n    return decodeToken(token);\n  }\n\n  public getTokenExpirationDate(token: string): Date | null;\n  public getTokenExpirationDate(token: Promise<string>): Promise<Date | null>;\n  public getTokenExpirationDate(\n    token: string | Promise<string> = this.tokenGetter()\n  ): Date | null | Promise<Date | null> {\n    if (token instanceof Promise) {\n      return token.then(decodeToken)\n                  .then((tokenValue) =>\n                    getTokenExpirationDate(tokenValue)\n                  );\n    }\n\n    return getTokenExpirationDate(decodeToken(token));\n  }\n\n  public isTokenExpired(token: string, offsetSeconds?: number): boolean;\n  public isTokenExpired(token: Promise<string>, offsetSeconds?: number): Promise<boolean>;\n  public isTokenExpired(\n    token: string | Promise<string> = this.tokenGetter(),\n    offsetSeconds?: number\n  ): boolean | Promise<boolean> {\n    if (token instanceof Promise) {\n      return token.then((tokenValue: string) =>\n        this.isTokenExpired(tokenValue, offsetSeconds)\n      );\n    }\n\n    if (!token || token === '') {\n      return true;\n    }\n\n    return isTokenExpired(token, offsetSeconds);\n  }\n\n  // @deprecated\n  public getAuthScheme(\n    authScheme: Function | string | undefined,\n    request: HttpRequest<any>\n  ): string {\n    if (typeof authScheme === 'function') {\n      return authScheme(request);\n    }\n\n    return authScheme;\n  }\n}\n","import { DOCUMENT } from '@angular/common';\nimport { HttpEvent, HttpHandler, HttpInterceptor, HttpRequest } from '@angular/common/http';\nimport { Inject, Injectable } from '@angular/core';\nimport { isTokenExpired } from 'angular-jwt/lib/jwt-utils';\nimport { from, Observable } from 'rxjs';\nimport { mergeMap } from 'rxjs/operators';\nimport { JwtHelperService } from './jwthelper.service';\nimport { JWT_OPTIONS } from './jwtoptions.token';\n\nexport type TokenGetter = (request?: HttpRequest<any>) => string | null | Promise<string | null>;\nexport type AuthScheme = string | ((request?: HttpRequest<any>) => string);\n\nexport function getAuthScheme(\n  authScheme: AuthScheme,\n  request: HttpRequest<any>\n): string {\n  if (typeof authScheme === 'function') {\n    return authScheme(request);\n  }\n\n  return authScheme;\n}\n\n@Injectable()\nexport class JwtInterceptor implements HttpInterceptor {\n  tokenGetter: TokenGetter;\n  headerName: string;\n  authScheme: AuthScheme;\n  allowedDomains: Array<string | RegExp>;\n  disallowedRoutes: Array<string | RegExp>;\n  throwNoTokenError: boolean;\n  skipWhenExpired: boolean;\n  standardPorts: string[] = ['80', '443'];\n\n  constructor(\n    @Inject(JWT_OPTIONS) config: any,\n    public jwtHelper: JwtHelperService,\n    @Inject(DOCUMENT) private document: Document\n  ) {\n    this.tokenGetter = config.tokenGetter;\n    this.headerName = config.headerName || 'Authorization';\n    this.authScheme =\n      config.authScheme || config.authScheme === ''\n        ? config.authScheme\n        : 'Bearer ';\n    this.allowedDomains = config.allowedDomains || [];\n    this.disallowedRoutes = config.disallowedRoutes || [];\n    this.throwNoTokenError = config.throwNoTokenError || false;\n    this.skipWhenExpired = config.skipWhenExpired;\n  }\n\n  isAllowedDomain(request: HttpRequest<any>): boolean {\n    const requestUrl: URL = new URL(request.url, this.document.location.origin);\n\n    // If the host equals the current window origin,\n    // the domain is allowed by default\n    if (requestUrl.host === this.document.location.host) {\n      return true;\n    }\n\n    // If not the current domain, check the allowed list\n    const hostName = `${requestUrl.hostname}${\n      requestUrl.port && !this.standardPorts.includes(requestUrl.port)\n        ? ':' + requestUrl.port\n        : ''\n    }`;\n\n    return (\n      this.allowedDomains.findIndex((domain) =>\n        typeof domain === 'string'\n          ? domain === hostName\n          : domain instanceof RegExp\n          ? domain.test(hostName)\n          : false\n      ) > -1\n    );\n  }\n\n  isDisallowedRoute(request: HttpRequest<any>): boolean {\n    const requestedUrl: URL = new URL(\n      request.url,\n      this.document.location.origin\n    );\n\n    return (\n      this.disallowedRoutes.findIndex((route: string | RegExp) => {\n        if (typeof route === 'string') {\n          const parsedRoute: URL = new URL(\n            route,\n            this.document.location.origin\n          );\n          return (\n            parsedRoute.hostname === requestedUrl.hostname &&\n            parsedRoute.pathname === requestedUrl.pathname\n          );\n        }\n\n        if (route instanceof RegExp) {\n          return route.test(request.url);\n        }\n\n        return false;\n      }) > -1\n    );\n  }\n\n  private handleInterception(\n    token: string | null,\n    request: HttpRequest<any>,\n    next: HttpHandler\n  ): Observable<HttpEvent<any>> {\n    const authScheme = getAuthScheme(this.authScheme, request);\n    let tokenIsExpired = false;\n\n    if (!token && this.throwNoTokenError) {\n      throw new Error('Could not get token from tokenGetter function.');\n    }\n\n    if (this.skipWhenExpired) {\n      tokenIsExpired = token ? isTokenExpired(token) : true;\n    }\n\n    if (token && tokenIsExpired && this.skipWhenExpired) {\n      request = request.clone();\n    } else if (token) {\n      request = request.clone({\n        setHeaders: {\n          [this.headerName]: `${authScheme}${token}`\n        }\n      });\n    }\n    return next.handle(request);\n  }\n\n  intercept(\n    request: HttpRequest<any>,\n    next: HttpHandler\n  ): Observable<HttpEvent<any>> {\n    if (!this.isAllowedDomain(request) || this.isDisallowedRoute(request)) {\n      return next.handle(request);\n    }\n\n    const token = this.tokenGetter(request);\n\n    if (token instanceof Promise) {\n      return from(token).pipe(\n        mergeMap((asyncToken: string | null) => {\n          return this.handleInterception(asyncToken, request, next);\n        })\n      );\n    } else {\n      return this.handleInterception(token, request, next);\n    }\n  }\n}\n","import {\n  NgModule,\n  ModuleWithProviders,\n  Optional,\n  SkipSelf,\n  Provider,\n} from '@angular/core';\nimport { HTTP_INTERCEPTORS } from '@angular/common/http';\nimport { AuthScheme, JwtInterceptor, TokenGetter } from './jwt.interceptor';\nimport { JWT_OPTIONS } from './jwtoptions.token';\nimport { JwtHelperService } from './jwthelper.service';\n\nexport interface JwtConfig {\n  tokenGetter?: TokenGetter;\n  headerName?: string;\n  authScheme?: AuthScheme;\n  allowedDomains?: Array<string | RegExp>;\n  disallowedRoutes?: Array<string | RegExp>;\n  throwNoTokenError?: boolean;\n  skipWhenExpired?: boolean;\n}\n\nexport interface JwtModuleOptions {\n  jwtOptionsProvider?: Provider;\n  config?: JwtConfig;\n}\n\n@NgModule()\nexport class JwtModule {\n  constructor(@Optional() @SkipSelf() parentModule: JwtModule) {\n    if (parentModule) {\n      throw new Error(\n        'JwtModule is already loaded. It should only be imported in your application\\'s main module.'\n      );\n    }\n  }\n\n  static forRoot(options: JwtModuleOptions): ModuleWithProviders<JwtModule> {\n    return {\n      ngModule: JwtModule,\n      providers: [\n        {\n          provide: HTTP_INTERCEPTORS,\n          useClass: JwtInterceptor,\n          multi: true\n        },\n        options.jwtOptionsProvider || {\n          provide: JWT_OPTIONS,\n          useValue: options.config\n        },\n        JwtHelperService\n      ]\n    };\n  }\n}\n"]}